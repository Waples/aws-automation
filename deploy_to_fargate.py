#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Wrapper script for Amazon AWS ECS:Fargate deployment, triggerd by Gitlab CI/CD
pipelines.

The following Gitlab CI/CD environment variables need to be set:
    - `ACCOUNT_ID`          > The AWS AccountId
    - `AWS_KEY`             > The AWS AccessKey
    - `AWS_KEYID`           > The AWS KeyId
    - `AWS_REGION`          > The AWS Region.
    - `AWS_REGISTRY_IMAGE`  > The name of the Docker image to use.
    - `BILLING_ENV`         > The identifier for billing.
    - `CI_ENVIRONMENT_SLUG` > The name of the Deployment (ex. Staging or
                              Production). This is generated by Gitlab CI/CD.
    - `STACK_NAME`          > The name of the Stack.

codeauthor: 'gn0mish@protonmail.com
version: 0.1
'''


# import python libs
import os
import sys

# import 3rd party libs
import botocore
import boto3

# TURN THIS OFF WHILE WORKING ON PRODUCTION!!
DEBUG = True
if DEBUG:
    import pprint

# Setting Gitlab CI/CD variables to python globals.
ACCOUNT_ID = os.environ['ACCOUNT_ID']
AWS_KEY = os.environ['AWS_KEY']
AWS_KEYID = os.environ['AWS_KEYID']
AWS_REGION = os.environ['AWS_REGION']
AWS_IMAGE = os.environ['AWS_REGISTRY_IMAGE']
BILLING_ENV = os.environ['BILLING_ENV']
CI_ENVIRONMENT_SLUG = os.environ['CI_ENVIRONMENT_SLUG']
STACK_NAME = os.environ['STACK_NAME']

# pylint struggles with long lines, so we disable it here.
# pylint: disable=C0301
def _get_conn(service='ecs'):
    '''
    Generates a boto3 client for the given service.

    :param str service: The service to generate client for. Defaults to AWS ECS.

    Inherits Gitlab CI/CD environment variables:
        - `AWS_KEYID`
        - `AWS_KEY`
        - `AWS_REGION`
    '''
    if DEBUG:
        print('[debug]  Creating client for {}'.format(service))
    return boto3.client(
        service,
        aws_access_key_id=AWS_KEYID,
        aws_secret_access_key=AWS_KEY,
        region_name=AWS_REGION,
    )


def _get_network_data():
    '''
    Collects network data from AWS EC2 service.

    Currently only does subnet and security group lookups, but may be
    expanded.

    Inherits Gitlab CI/CD environment variables:
        - `STACK_NAME`
    '''
    ret = {
            'secgrps': [],
            'subnets': [],
            'result': False,
        }
    try:
        conn = _get_conn(service='ec2')
        if DEBUG:
            print('[debug]  Collecting network data')
        sec_fil = {
                'Name': 'tag:Name',
                'Values': [STACK_NAME + '-' + CI_ENVIRONMENT_SLUG + '-fargate']
        }
        secgrp_data = conn.describe_security_groups(Filters=[sec_fil])['SecurityGroups']
        for secgrp in secgrp_data:
            ret['secgrps'].append(secgrp['GroupId'])
        sub_fil = {
                'Name': 'tag:Name',
                'Values': [
                    'public-1-' + CI_ENVIRONMENT_SLUG,
                    'public-2-' + CI_ENVIRONMENT_SLUG,
                ]
        }
        subnet_data = conn.describe_subnets(Filters=[sub_fil])['Subnets']
        for subnet in subnet_data:
            ret['subnets'].append(subnet['SubnetId'])
        ret['result'] = True
        if DEBUG:
            pprint.pprint(ret)
    except botocore.exceptions.ClientError as err:
        sys.exit(err)
    return ret


def deploy():
    '''
    Wrapper function to check if we need to provision new task(s) or service(s).

    TODO:
        - Improve error handling
    '''
    ret = False
    try:
        print('[Deploying to AWS ECS:Fargate]')
        tasks = register_task()
        services = check_services()
        if tasks and services:
            print('\t✓ Deployed to AWS:ECS Fargate!')
            ret = True
        else:
            sys.exit('[ERROR]  Something is wrong, and you need to check it..')
    except Exception as err:
        sys.exit(err)
    return ret


def check_services():
    '''
    Wrapper function to check if we need to create or update service(s).

    Inherits Gitlab CI/CD environment variables:
        - `CI_ENVIRONMENT_SLUG`
        - `STACK_NAME`

    TODO:
        - Improve error handling
    '''
    ret = False
    try:
        conn = _get_conn()
        if DEBUG:
            print('[debug]  Checking services')
        service = conn.describe_services(
            cluster=STACK_NAME,
            services=[STACK_NAME + '-' + CI_ENVIRONMENT_SLUG])['services']
        if DEBUG:
            pprint.pprint(service)
        if service and service[0]['status'] == 'ACTIVE':
            if DEBUG:
                print('[debug]  Updating existing service')
            if update_service():
                ret = True
        else:
            create_service()
            ret = True
    except botocore.exceptions.ClientError as err:
        sys.exit(err)
    return ret


def create_service():
    '''
    Creates an AWS ECS service from the given Task Definition.

    Inherits Gitlab CI/CD environment variables:
        - `CI_ENVIRONMENT_SLUG`
        - `STACK_NAME`
    '''
    ret = False
    try:
        conn = _get_conn()
        if DEBUG:
            print('[debug]  Creating services')
        data = _get_network_data()
        conn.create_service(
            cluster=STACK_NAME,
            serviceName=STACK_NAME + '-' + CI_ENVIRONMENT_SLUG,
            taskDefinition=STACK_NAME + '-' + CI_ENVIRONMENT_SLUG,
            desiredCount=1,
            launchType='FARGATE',
            platformVersion='LATEST',
            deploymentConfiguration={
                'maximumPercent': 200,
                'minimumHealthyPercent': 80,
            },
            networkConfiguration={
                'awsvpcConfiguration': {
                    'subnets': data['subnets'],
                    'securityGroups': data['secgrps'],
                    'assignPublicIp': 'ENABLED',
                }
            },
        )
        ret = True
        print('\t✓ Created service')
    except botocore.exceptions.ClientError as err:
        sys.exit(err)
    return ret


def register_task():
    '''
    Registers a task definition for AWS ECS

    Inherits Gitlab CI/CD environment variables:
        - `ACCOUNT_ID`
        - `AWS_REGISTRY_IMAGE`
        - `CI_ENVIRONMENT_SLUG`
        - `STACK_NAME`
    '''
    ret = False
    try:
        conn = _get_conn()
        if DEBUG:
            print('[debug]  Registering Task Definition')
        conn.register_task_definition(
            volumes=[],
            family=STACK_NAME + '-' + CI_ENVIRONMENT_SLUG,
            executionRoleArn='arn:aws:iam::' + ACCOUNT_ID +':role/ecsTaskExecutionRole',
            networkMode='awsvpc',
            requiresCompatibilities=['FARGATE'],
            cpu='256',
            memory='512',
            tags=[
                {
                    'key': 'Billing_Env',
                    'value': BILLING_ENV
                }
            ],
            containerDefinitions=[
                {
                    'name': STACK_NAME,
                    'image': AWS_IMAGE + ':' + CI_ENVIRONMENT_SLUG,
                    'cpu': 2,
                    'memory': 512,
                    'memoryReservation': 300,
                    'portMappings': [
                        {
                            'containerPort': 3000,
                            'hostPort': 3000,
                            'protocol': 'tcp',
                        }
                    ],
                    'volumesFrom': [],
                    'logConfiguration': {
                        'logDriver': 'awslogs',
                        'options': {
                            'awslogs-group': '/ecs/' + STACK_NAME,
                            'awslogs-region': AWS_REGION,
                            'awslogs-stream-prefix': 'ecs'
                        }
                    }
                }
            ]
        )
        print('\t✓ Registered Task Definition')
        ret = True
    except botocore.exceptions.ClientError as err:
        sys.exit(err)
    return ret


def update_service():
    '''
    Updates an AWS ECS service from the given Task Definition.

    Inherits Gitlab CI/CD environment variables:
        - `CI_ENVIRONMENT_SLUG`
        - `STACK_NAME`
    '''
    ret = False
    try:
        conn = _get_conn()
        if DEBUG:
            print('[debug]  Updating service')
        conn.update_service(
            cluster=STACK_NAME,
            service=STACK_NAME + '-' + CI_ENVIRONMENT_SLUG,
            desiredCount=1,
            taskDefinition=STACK_NAME + '-' + CI_ENVIRONMENT_SLUG,
            deploymentConfiguration={
                'maximumPercent': 200,
                'minimumHealthyPercent': 80,
            },
            platformVersion='LATEST',
            forceNewDeployment=True,
        )
        ret = True
        print('\t✓ Updated service')
    except botocore.exceptions.ClientError as err:
        print(err)
        sys.exit(err)
    return ret


if __name__ == '__main__':
    deploy()
